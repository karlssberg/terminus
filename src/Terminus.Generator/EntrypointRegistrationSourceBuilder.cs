using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Terminus.Generator;

internal static class EntrypointRegistrationSourceBuilder
{
    internal static CompilationUnitSyntax Generate(ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EndpointDiscoveryGenerator
            #if NET6_0_OR_GREATER
            #nullable enable
            #endif

            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Strategies;

            namespace Terminus.Generated
            {
                public static class ServiceCollectionExtensions
                {
                    public static IServiceCollection AddEntryPoints<TAttribute>(
                        this IServiceCollection services,
                        Action<ParameterBindingStrategyResolver>? resolverConfigurator = null)
                        where TAttribute : EntryPointAttribute
                    {
                        var resolver = new ParameterBindingStrategyResolver();
                        if (resolverConfigurator != null)
                        {
                            resolverConfigurator(resolver);
                        }
                        else
                        {
                            resolver.AddDefault();
                        }
                        
                        {{CreateServiceRegistrationIfElseChain("TAttribute", entryPoints)}}
                        
                        return services;
                    }
                    
                    public static IServiceCollection AddEntryPoints(this IServiceCollection services, Action<ParameterBindingStrategyResolver> resolverConfigurator) => 
                        services.AddEntryPoints<EntryPointAttribute>(resolverConfigurator);
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    private static StatementSyntax CreateServiceRegistrationIfElseChain(
        string attributeGenericParameter,
        IEnumerable<EntryPointMethodInfo> entryPoints)
    {
        var ifElseChainSyntax = entryPoints
            .GroupBy<EntryPointMethodInfo, INamedTypeSymbol>(
                entry => entry.AttributeData.AttributeClass!,
                SymbolEqualityComparer.Default)
            .Select(groupedEntryPoints =>
            {
                var attributeType = groupedEntryPoints.Key;
                return IfStatement(
                    ParseExpression($"typeof({attributeType.ToDisplayString()}) == typeof({attributeGenericParameter})"),
                    Block(CreateServiceRegistrations(groupedEntryPoints)));
            })
            .Reverse()
            .Aggregate(
                (StatementSyntax)Block(
                    ThrowStatement(
                        ParseExpression("""new InvalidOperationException($"Attribute '{typeof(TAttribute)}' is not applied to any methods.")"""))),
                (after, before) => before.WithElse(ElseClause(after)));
        
        return ifElseChainSyntax.NormalizeWhitespace();
    }
 
    private static IEnumerable<StatementSyntax> CreateServiceRegistrations(IEnumerable<EntryPointMethodInfo> entryPoints)
    {
        var statements = entryPoints
            .Select(CreateRegistrationInvoker)
            .Select(source => ParseExpression(source))
            .Select(ExpressionStatement);

        return statements;
        
        string CreateRegistrationInvoker(EntryPointMethodInfo info)
        {
            return $$"""
                     services.AddKeyedSingleton<EntryPointDescriptor>(
                         typeof(TAttribute),
                         {{CreateEntryPointDescriptorMappingSyntax(info)}})
                     """;
        }
    }

    private static ExpressionSyntax CreateEntryPointDescriptorMappingSyntax(EntryPointMethodInfo info)
    {
        var containingType = info.MethodSymbol.ContainingType.ToDisplayString();
        var methodNameLiteral = LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(info.MethodSymbol.Name));

        // Build typeof(ContainingType).GetMethod("MethodName", new[] { typeof(ParamType1), ... })
        var typeOfContaining = ParseExpression($"typeof({containingType})");
        var getMethodMemberAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            typeOfContaining,
            IdentifierName("GetMethod"));

        var typeArrayExpr = ArrayCreationExpression(
                ArrayType(ParseTypeName("System.Type")).WithoutRank())
            .WithInitializer(info.MethodSymbol.Parameters.Length == 0
                ? Array.Empty<ExpressionSyntax>()
                : info.MethodSymbol.Parameters.Select(p => ParseExpression($"typeof({p.Type.ToDisplayString()})")));

        var getMethodInvocation = InvocationExpression(getMethodMemberAccess)
            .WithArguments(methodNameLiteral, typeArrayExpr)
            .NormalizeWhitespace();

        // Build invoker: static -> ContainingType.Method(args); instance -> ((ContainingType)instance).Method(args)
        ExpressionSyntax invocationTarget = info.MethodSymbol.IsStatic
            ? ParseExpression($"{containingType}.{info.MethodSymbol.Name}")
            : ParseExpression($"(({containingType})instance).{info.MethodSymbol.Name}");

        var instanceInvoke = InvocationExpression(invocationTarget)
            .WithArguments(CreateEntryPointMethodArguments(info))
            .NormalizeWhitespace();

        var source =
          $"""
            new EntryPointDescriptor(
                {getMethodInvocation},
                (instance, context) => {instanceInvoke})
            """;
        return ParseExpression(source).NormalizeWhitespace();
    }

    private static IEnumerable<ExpressionSyntax> CreateEntryPointMethodArguments(EntryPointMethodInfo info)
    {
        return info.MethodSymbol.Parameters.Select(parameter =>
        {
            var paramType = parameter.Type.ToDisplayString();
            var source =
              $"""
                resolver.ResolveParameter<{paramType}>("{parameter.Name}", context)
                """;
            return ParseExpression(source);
        });
    }
}