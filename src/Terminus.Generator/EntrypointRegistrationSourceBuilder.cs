using System.Collections.Immutable;
using System.Linq;
using System.Reflection.Metadata;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Terminus.Generator;

internal static class EntrypointRegistrationSourceBuilder
{
    // New method: Generate for a specific mediator interface
    internal static CompilationUnitSyntax GenerateForMediator(
        MediatorInterfaceInfo mediator,
        ImmutableArray<EntryPointMethodInfo> matchingEntryPoints,
        ImmutableArray<EntryPointMethodInfo> allEntryPoints)
    {
        var interfaceName = mediator.InterfaceSymbol.Name;
        var interfaceNamespace = mediator.InterfaceSymbol.ContainingNamespace.ToDisplayString();
        var implementationClassName = $"{interfaceName}_Generated";
        var attributeTypeName = mediator.EntryPointAttributeType.ToDisplayString();

        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EndpointDiscoveryGenerator
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Attributes;
            using Terminus.Strategies;

            namespace {{interfaceNamespace}}
            {
                {{CreateMediatorInterfaceExtension(mediator.InterfaceSymbol, matchingEntryPoints)}}

                {{CreateMediatorClassImplementation(mediator.InterfaceSymbol, implementationClassName, matchingEntryPoints)}}
            }

            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    {{CreateAddEntryPointsExtension(mediator, matchingEntryPoints, allEntryPoints, interfaceNamespace, implementationClassName)}}
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    // Legacy method: Generate global file when no mediators are defined
    // This provides backward compatibility for projects not using [EntryPointMediator]
    internal static CompilationUnitSyntax GenerateLegacy(ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EndpointDiscoveryGenerator
            // WARNING: No mediator interfaces found. Define interfaces with [EntryPointMediator] attribute.
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Attributes;
            using Terminus.Strategies;

            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    public static IServiceCollection AddEntryPoints<TAttribute>(
                        this IServiceCollection services,
                        Action<ParameterBindingStrategyResolver>? configure = null)
                        where TAttribute : EntryPointAttribute
                    {
                        var resolver = new ParameterBindingStrategyResolver();
                        configure?.Invoke(resolver);

                        {{CreateServiceRegistrationIfElseChain("TAttribute", entryPoints)}}

                        return services;
                    }

                    public static IServiceCollection AddEntryPoints(
                        this IServiceCollection services,
                        Action<ParameterBindingStrategyResolver>? configure = null)
                    {
                        return services.AddEntryPoints<Terminus.Attributes.EntryPointAttribute>(configure);
                    }
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    // Helper methods for per-mediator generation
    private static string CreateMediatorInterfaceExtension(
        INamedTypeSymbol interfaceSymbol,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var methods = string.Join("\n    ", entryPoints.Select(ep =>
        {
            var parameters = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                $"{p.Type.ToDisplayString()} {p.Name}"));
            var returnType = ep.MethodSymbol.ReturnsVoid ? "void" : ep.MethodSymbol.ReturnType.ToDisplayString();
            return $"{returnType} {ep.MethodSymbol.Name}({parameters});";
        }));

        return
          $$"""
           public partial interface {{interfaceSymbol.Name}}
           {
               {{methods}}
           }
           """;
    }

    private static string CreateMediatorClassImplementation(
        INamedTypeSymbol interfaceSymbol,
        string implementationClassName,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var methods = string.Join("\n\n    ", entryPoints.Select(CreateMediatorMethodImplementation));

        return
          $$"""
           internal sealed class {{implementationClassName}} : {{interfaceSymbol.ToDisplayString()}}
           {
               private readonly IServiceProvider _serviceProvider;
               private readonly ParameterBindingStrategyResolver _resolver;

               public {{implementationClassName}}(IServiceProvider serviceProvider, ParameterBindingStrategyResolver resolver)
               {
                   _serviceProvider = serviceProvider;
                   _resolver = resolver;
               }

               {{methods}}
           }
           """;
    }

    private static string CreateMediatorMethodImplementation(EntryPointMethodInfo entryPoint)
    {
        var parameters = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var returnType = entryPoint.MethodSymbol.ReturnsVoid ? "void" : entryPoint.MethodSymbol.ReturnType.ToDisplayString();

        var serviceResolution = entryPoint.MethodSymbol.IsStatic
            ? entryPoint.MethodSymbol.ContainingType.ToDisplayString()
            : $"scope.ServiceProvider.GetRequiredService<{entryPoint.MethodSymbol.ContainingType.ToDisplayString()}>()";

        var methodArgs = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p =>
            $"_resolver.ResolveParameter<{p.Type.ToDisplayString()}>(\"{p.Name}\", context)"));

        var contextData = "new System.Collections.Generic.Dictionary<string, object?> { " +
            string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p =>
                $"{{ \"{p.Name}\", {p.Name} }}")) + " }";

        var invocation = $"{serviceResolution}.{entryPoint.MethodSymbol.Name}({methodArgs})";
        var returnStatement = entryPoint.MethodSymbol.ReturnsVoid ? "" : "return ";

        return
          $$"""
           public {{returnType}} {{entryPoint.MethodSymbol.Name}}({{parameters}})
           {
               using (var scope = _serviceProvider.CreateScope())
               {
                   var context = new ParameterBindingContext(
                       string.Empty,
                       typeof(object),
                       scope.ServiceProvider,
                       {{contextData}});
                   {{returnStatement}}{{invocation}};
               }
           }
           """;
    }

    private static string CreateAddEntryPointsExtension(
        MediatorInterfaceInfo mediator,
        ImmutableArray<EntryPointMethodInfo> matchingEntryPoints,
        ImmutableArray<EntryPointMethodInfo> allEntryPoints,
        string interfaceNamespace,
        string implementationClassName)
    {
        var attributeTypeName = mediator.EntryPointAttributeType.ToDisplayString();
        var interfaceFullName = $"{interfaceNamespace}.{mediator.InterfaceSymbol.Name}";

        var registrations = string.Join("\n            ", matchingEntryPoints.Select(ep =>
        {
            var methodName = ep.MethodSymbol.Name;
            var containingType = ep.MethodSymbol.ContainingType.ToDisplayString();
            var paramTypes = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                $"typeof({p.Type.ToDisplayString()})"));
            var paramArray = ep.MethodSymbol.Parameters.Length == 0
                ? "System.Array.Empty<System.Type>()"
                : $"new System.Type[] {{ {paramTypes} }}";

            return $"services.AddSingleton<EntryPointDescriptor<{attributeTypeName}>>(CreateDescriptor(typeof({containingType}).GetMethod(\"{methodName}\", {paramArray})!, resolver));";
        }));

        return
          $$"""
           public static IServiceCollection AddEntryPoints{{mediator.InterfaceSymbol.Name}}(
               this IServiceCollection services,
               Action<ParameterBindingStrategyResolver>? configure = null)
           {
               var resolver = new ParameterBindingStrategyResolver();
               configure?.Invoke(resolver);

               static EntryPointDescriptor<{{attributeTypeName}}> CreateDescriptor(
                   MethodInfo method,
                   ParameterBindingStrategyResolver resolver) =>
                   new EntryPointDescriptor<{{attributeTypeName}}>(method, (instance, context) => {
                       throw new NotImplementedException("Direct descriptor invocation not yet supported");
                   });

               {{registrations}}

               services.AddSingleton<{{interfaceFullName}}, {{interfaceNamespace}}.{{implementationClassName}}>();
               services.AddSingleton(resolver);

               return services;
           }
           """;
    }

    // Old legacy methods removed - now using per-mediator generation approach

    private static StatementSyntax CreateServiceRegistrationIfElseChain(
        string attributeGenericParameter,
        IEnumerable<EntryPointMethodInfo> entryPoints)
    {
        var ifElseChainSyntax = entryPoints
            .GroupBy<EntryPointMethodInfo, INamedTypeSymbol>(
                entry => entry.AttributeData.AttributeClass!,
                SymbolEqualityComparer.Default)
            .Select(groupedEntryPoints =>
            {
                var attributeType = groupedEntryPoints.Key;
                return IfStatement(
                    ParseExpression($"typeof({attributeType.ToDisplayString()}) == typeof({attributeGenericParameter})"),
                    Block(CreateServiceRegistrations(attributeGenericParameter, groupedEntryPoints)));
            })
            .Reverse()
            .Aggregate(
                (StatementSyntax)Block(
                    ThrowStatement(
                        ParseExpression("""new InvalidOperationException($"'{typeof(TAttribute)}' is not applied to any methods")"""))),
                (after, before) => before.WithElse(ElseClause(after)));
        
        return ifElseChainSyntax.NormalizeWhitespace();
    }
 
    private static IEnumerable<StatementSyntax> CreateServiceRegistrations(
        string attributeGenericParameter,
        IEnumerable<EntryPointMethodInfo> entryPoints)
    {
        var statements = entryPoints
            .Select(CreateRegistrationInvoker)
            .Select(source => ParseExpression(source))
            .Select(ExpressionStatement);

        return statements;
        
        string CreateRegistrationInvoker(EntryPointMethodInfo info)
        {
            return 
                $"""
                 services.AddSingleton<EntryPointDescriptor<{attributeGenericParameter}>>(
                     {CreateEntryPointDescriptorMappingSyntax(info)})
                 """;
        }
    }

    private static ExpressionSyntax CreateEntryPointDescriptorMappingSyntax(EntryPointMethodInfo info)
    {
        var containingType = info.MethodSymbol.ContainingType.ToDisplayString();
        var methodNameLiteral = LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(info.MethodSymbol.Name));

        // Build typeof(ContainingType).GetMethod("MethodName", new[] { typeof(ParamType1), ... })
        var typeOfContaining = ParseExpression($"typeof({containingType})");
        var getMethodMemberAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            typeOfContaining,
            IdentifierName("GetMethod"));

        var typeArrayExpr = ArrayCreationExpression(
                ArrayType(ParseTypeName("System.Type")).WithoutRank())
            .WithInitializer(info.MethodSymbol.Parameters.Length == 0
                ? []
                : info.MethodSymbol.Parameters.Select(p => ParseExpression($"typeof({p.Type.ToDisplayString()})")));

        var getMethodInvocation = InvocationExpression(getMethodMemberAccess)
            .WithArguments(methodNameLiteral, typeArrayExpr)
            .NormalizeWhitespace();

        // Build invoker: static -> ContainingType.Method(args); instance -> ((ContainingType)instance).Method(args)
        var invocationTarget = info.MethodSymbol.IsStatic
            ? ParseExpression($"{containingType}.{info.MethodSymbol.Name}")
            : ParseExpression($"(({containingType})instance).{info.MethodSymbol.Name}");

        var instanceInvoke = InvocationExpression(invocationTarget)
            .WithArguments(CreateEntryPointMethodArguments(info))
            .NormalizeWhitespace();

        var source =
          $"""
            new EntryPointDescriptor<TAttribute>(
                {getMethodInvocation},
                (instance, context) => {instanceInvoke})
            """;
        return ParseExpression(source).NormalizeWhitespace();
    }

    private static IEnumerable<ExpressionSyntax> CreateEntryPointMethodArguments(EntryPointMethodInfo info)
    {
        return info.MethodSymbol.Parameters.Select(parameter =>
        {
            var paramType = parameter.Type.ToDisplayString();
            var source =
              $"""
                resolver.ResolveParameter<{paramType}>("{parameter.Name}", context)
                """;
            return ParseExpression(source);
        });
    }
}