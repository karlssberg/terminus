using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Terminus.Generator;

internal static class EntrypointRegistrationSourceBuilder
{
    internal static CompilationUnitSyntax GenerateForMediator(
        MediatorInterfaceInfo mediator,
        ImmutableArray<EntryPointMethodInfo> matchingEntryPoints)
    {
        var interfaceName = mediator.InterfaceSymbol.Name;
        var interfaceNamespace = mediator.InterfaceSymbol.ContainingNamespace.ToDisplayString();
        var implementationClassName = $"{interfaceName}_Generated";

        var interfaceNameSpaceDeclaration = NamespaceDeclaration(ParseName(interfaceNamespace))
            .WithMembers(
                [
                    CreateMediatorInterfaceExtensionDeclaration(mediator.InterfaceSymbol, matchingEntryPoints),
                    CreateMediatorClassImplementation(mediator.InterfaceSymbol, implementationClassName, matchingEntryPoints)
                ])
            .NormalizeWhitespace();

        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EntryPointDiscoveryGenerator
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Attributes;
            using Terminus.Strategies;

            {{interfaceNameSpaceDeclaration}}

            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    {{CreateAddEntryPointsExtension(mediator, matchingEntryPoints, interfaceNamespace, implementationClassName)}}
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    private static InterfaceDeclarationSyntax CreateMediatorInterfaceExtensionDeclaration(
        INamedTypeSymbol interfaceSymbol,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        return InterfaceDeclaration(interfaceSymbol.Name)
            .WithModifiers(TokenList(Token(
                SyntaxKind.PublicKeyword), 
                Token(SyntaxKind.PartialKeyword)))
            .WithMembers(
                entryPoints
                    .Select(ep => ep.MethodSymbol.ToMethodDeclarationSyntax().WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))
                    .ToListSyntax<MemberDeclarationSyntax>())
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax CreateMediatorClassImplementation(
        INamedTypeSymbol interfaceSymbol,
        string implementationClassName,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        return ClassDeclaration(implementationClassName)
            .WithModifiers([Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.SealedKeyword)])
            .AddBaseListTypes(SimpleBaseType(ParseTypeName(interfaceSymbol.ToDisplayString())))
            .WithMembers(
            [
                ParseMemberDeclaration("private readonly IServiceProvider _serviceProvider;")!,
                ParseMemberDeclaration("private readonly ParameterBindingStrategyResolver _resolver;")!,
                ParseMemberDeclaration(
                   $$"""
                     public {{implementationClassName}}(IServiceProvider serviceProvider, ParameterBindingStrategyResolver resolver)
                     {
                         _serviceProvider = serviceProvider;
                         _resolver = resolver;
                     }
                     """)!,
                ..entryPoints.Select(CreateMediatorMethodImplementation),
            ]);
    }

    private static MemberDeclarationSyntax CreateMediatorMethodImplementation(EntryPointMethodInfo entryPoint)
    {
        var parameters = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var returnType = entryPoint.MethodSymbol.ReturnsVoid ? "void" : entryPoint.MethodSymbol.ReturnType.ToDisplayString();

        var serviceResolution = entryPoint.MethodSymbol.IsStatic
            ? entryPoint.MethodSymbol.ContainingType.ToDisplayString()
            : $"scope.ServiceProvider.GetRequiredService<{entryPoint.MethodSymbol.ContainingType.ToDisplayString()}>()";

        var methodArgs = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p => p.Name));

        var invocation = $"{serviceResolution}.{entryPoint.MethodSymbol.Name}({methodArgs})";
        var returnStatement = entryPoint.MethodSymbol.ReturnsVoid ? "" : "return ";

        var source =
          $$"""
           public {{returnType}} {{entryPoint.MethodSymbol.Name}}({{parameters}})
           {
               using (var scope = _serviceProvider.CreateScope())
               {
                   {{returnStatement}}{{invocation}};
               }
           }
           """;
        return ParseMemberDeclaration(source)!.NormalizeWhitespace();
    }

    private static string CreateAddEntryPointsExtension(
        MediatorInterfaceInfo mediator,
        ImmutableArray<EntryPointMethodInfo> matchingEntryPoints,
        string interfaceNamespace,
        string implementationClassName)
    {
        var attributeTypeName = mediator.EntryPointAttributeType.ToDisplayString();
        var interfaceFullName = $"{interfaceNamespace}.{mediator.InterfaceSymbol.Name}";


        // Generate the CreateDescriptor lambda body that invokes the appropriate mediator method
     
        var registrationCollection = matchingEntryPoints.Select(ep =>
        {
            var methodName = ep.MethodSymbol.Name;
            var containingType = ep.MethodSymbol.ContainingType.ToDisplayString();
            var paramTypes = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                $"typeof({p.Type.ToDisplayString()})"));
            var paramArray = ep.MethodSymbol.Parameters.Length == 0
                ? "new System.Type[] { }"
                : $"new System.Type[] {{ {paramTypes} }}";
            
            var parameterInvocations = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                p.Type.ToDisplayString() == "System.Threading.CancellationToken"
                    ? "ct"
                    : $"resolver.ResolveParameter<{p.Type.ToDisplayString()}>(\"{p.Name}\", context)"));

            var invokeExpressionSnippet = ep.MethodSymbol.IsStatic
                ? $"{containingType}.{methodName}({parameterInvocations})"
                : $"context.ServiceProvider.GetRequiredService<{containingType}>().{methodName}({parameterInvocations})";
                
            var invokeExpression = ParseExpression(invokeExpressionSnippet);

            var registrationExpressionStatement =
                $"services.AddSingleton<EntryPointDescriptor<{attributeTypeName}>>(new EntryPointDescriptor<{attributeTypeName}>(typeof({containingType}).GetMethod(\"{methodName}\", {paramArray})!, (context, ct) => {invokeExpression}));";
            return ParseStatement(registrationExpressionStatement);
        });

        var registrations = List(registrationCollection);

        return
          $$"""
           public static IServiceCollection AddEntryPointsFor{{mediator.InterfaceSymbol.Name}}(
               this IServiceCollection services,
               Action<ParameterBindingStrategyResolver>? configure = null)
           {
               var resolver = new ParameterBindingStrategyResolver();
               configure?.Invoke(resolver);
               services.AddSingleton(resolver);

               {{registrations}}

               services.AddSingleton<{{interfaceFullName}}, {{interfaceNamespace}}.{{implementationClassName}}>();

               return services;
           }
           """;
    }
}