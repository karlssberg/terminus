using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Terminus.Generator;

internal static class EntrypointRegistrationSourceBuilder
{
    internal static CompilationUnitSyntax Generate(
        INamedTypeSymbol entryPointAttributeType,
        ImmutableArray<EntryPointMethodInfo> entryPointMethodInfos,
        ImmutableArray<MediatorInterfaceInfo> mediators)
    {
        var mediatorTypeDeclarations = mediators
            .Select(mediator => CreateMediatorTypeDeclarations(mediator, entryPointMethodInfos))
            .ToListSyntax();
        
        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EntryPointDiscoveryGenerator
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Attributes;
            using Terminus.Strategies;

            {{mediatorTypeDeclarations}}

            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    {{CreateAddEntryPointsExtension(entryPointAttributeType, mediators, entryPointMethodInfos)}}
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    private static NamespaceDeclarationSyntax CreateMediatorTypeDeclarations(MediatorInterfaceInfo mediator, ImmutableArray<EntryPointMethodInfo> matchingEntryPoints)
    {
        var interfaceNamespace = mediator.InterfaceSymbol.ContainingNamespace.ToDisplayString();
        return NamespaceDeclaration(ParseName(interfaceNamespace))
            .WithMembers(
            [
                CreateMediatorInterfaceExtensionDeclaration(mediator, matchingEntryPoints),
                CreateMediatorClassImplementation(mediator, matchingEntryPoints)
            ])
            .NormalizeWhitespace();
    }

    private static InterfaceDeclarationSyntax CreateMediatorInterfaceExtensionDeclaration(
        MediatorInterfaceInfo mediatorInfo,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        return InterfaceDeclaration(mediatorInfo.InterfaceSymbol.Name)
            .WithModifiers(TokenList(Token(
                SyntaxKind.PublicKeyword), 
                Token(SyntaxKind.PartialKeyword)))
            .WithMembers(
                entryPoints
                    .Select(ep => ep.MethodSymbol.ToMethodDeclarationSyntax().WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))
                    .ToListSyntax<MemberDeclarationSyntax>())
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax CreateMediatorClassImplementation(
        MediatorInterfaceInfo mediatorInfo,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var implementationClassName = mediatorInfo.GetImplementationClassName();
        return ClassDeclaration(implementationClassName)
            .WithModifiers([Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.SealedKeyword)])
            .AddBaseListTypes(SimpleBaseType(ParseTypeName(mediatorInfo.InterfaceSymbol.ToDisplayString())))
            .WithMembers(
            [
                ParseMemberDeclaration("private readonly IServiceProvider _serviceProvider;")!,
                ParseMemberDeclaration("private readonly ParameterBindingStrategyResolver _resolver;")!,
                ParseMemberDeclaration(
                   $$"""
                     public {{implementationClassName}}(IServiceProvider serviceProvider, ParameterBindingStrategyResolver resolver)
                     {
                         _serviceProvider = serviceProvider;
                         _resolver = resolver;
                     }
                     """)!,
                ..entryPoints.Select(CreateMediatorMethodImplementation),
            ]);
    }

    private static MemberDeclarationSyntax CreateMediatorMethodImplementation(EntryPointMethodInfo entryPoint)
    {
        var parameters = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var returnType = entryPoint.MethodSymbol.ReturnsVoid ? "void" : entryPoint.MethodSymbol.ReturnType.ToDisplayString();

        var serviceResolution = entryPoint.MethodSymbol.IsStatic
            ? entryPoint.MethodSymbol.ContainingType.ToDisplayString()
            : $"scope.ServiceProvider.GetRequiredService<{entryPoint.MethodSymbol.ContainingType.ToDisplayString()}>()";

        var methodArgs = string.Join(", ", entryPoint.MethodSymbol.Parameters.Select(p => p.Name));

        var invocation = $"{serviceResolution}.{entryPoint.MethodSymbol.Name}({methodArgs})";
        var returnStatement = entryPoint.MethodSymbol.ReturnsVoid ? "" : "return ";

        var source =
          $$"""
           public {{returnType}} {{entryPoint.MethodSymbol.Name}}({{parameters}})
           {
               using (var scope = _serviceProvider.CreateScope())
               {
                   {{returnStatement}}{{invocation}};
               }
           }
           """;
        return ParseMemberDeclaration(source)!.NormalizeWhitespace();
    }

    private static string CreateAddEntryPointsExtension(
        INamedTypeSymbol entryPointAttributeType,
        ImmutableArray<MediatorInterfaceInfo> mediators,
        ImmutableArray<EntryPointMethodInfo> entryPointMethodInfos)
    {
        var attributeTypeName = entryPointAttributeType.ToDisplayString();
     
        var registrationCollection = entryPointMethodInfos.Select(ep =>
        {
            var methodName = ep.MethodSymbol.Name;
            var containingType = ep.MethodSymbol.ContainingType.ToDisplayString();
            var paramTypes = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                $"typeof({p.Type.ToDisplayString()})"));
            var paramArray = ep.MethodSymbol.Parameters.Length == 0
                ? "new System.Type[] { }"
                : $"new System.Type[] {{ {paramTypes} }}";
            
            var parameterInvocations = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                p.Type.ToDisplayString() == "System.Threading.CancellationToken"
                    ? "ct"
                    : $"resolver.ResolveParameter<{p.Type.ToDisplayString()}>(\"{p.Name}\", context)"));

            var invokeExpressionSnippet = ep.MethodSymbol.IsStatic
                ? $"{containingType}.{methodName}({parameterInvocations})"
                : $"context.ServiceProvider.GetRequiredService<{containingType}>().{methodName}({parameterInvocations})";
                
            var invokeExpression = ParseExpression(invokeExpressionSnippet);

            var registrationExpressionStatement =
                $"services.AddSingleton<EntryPointDescriptor<{attributeTypeName}>>(new EntryPointDescriptor<{attributeTypeName}>(typeof({containingType}).GetMethod(\"{methodName}\", {paramArray})!, (context, ct) => {invokeExpression}));";
            return ParseStatement(registrationExpressionStatement);
        });

        var registrations = List(registrationCollection);
        
        var mediatorServiceRegistrations = mediators
            .Select(mediator => ParseExpression(
                $"services.AddSingleton<{mediator.InterfaceSymbol.ToDisplayString()}, {mediator.GetImplementationClassFullName()}>()"))
            .Select(ExpressionStatement)
            .ToListSyntax();

        return
          $$"""
            private static IServiceCollection AddEntryPointsFor_{{attributeTypeName.EscapeIdentifierName()}}(
                this IServiceCollection services,
                Action<ParameterBindingStrategyResolver>? configure = null)
            {
                var resolver = new ParameterBindingStrategyResolver();
                configure?.Invoke(resolver);
                services.AddSingleton(resolver);
                services.AddTransient<IDispatcher<{{attributeTypeName}}>, ScopedDispatcher<{{attributeTypeName}}>>();
                services.AddTransient<IAsyncDispatcher<{{attributeTypeName}}>, ScopedDispatcher<{{attributeTypeName}}>>();
                services.AddTransient<IEntryPointRouter<{{attributeTypeName}}>, DefaultEntryPointRouter<{{attributeTypeName}}>>();
 
                {{registrations}}
 
                {{mediatorServiceRegistrations}}
 
                return services;
            }
            """;
    }

    public static CompilationUnitSyntax Generate(IEnumerable<INamedTypeSymbol> entryPointAttributeTypes)
    {
        var switchExpression =
            SwitchStatement(ParseExpression("typeof(T).FullName"))
                .AddSections(entryPointAttributeTypes
                    .Select(attributeType =>
                        SwitchSection()
                            .AddLabels(
                                CaseSwitchLabel(LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    Literal(attributeType.ToDisplayString()))))
                            .AddStatements(
                                ReturnStatement(
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("services"),
                                            IdentifierName(
                                                $"AddEntryPointsFor_{attributeType.ToDisplayString().EscapeIdentifierName()}")))
                                        .WithArgumentList(ParseArgumentList("(configure)")))))
                    .ToArray())
                .NormalizeWhitespace();
        
        return ParseCompilationUnit(
          $$"""
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using Terminus.Attributes;
            
            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    public static IServiceCollection AddEntryPointsFor<T>(
                        this IServiceCollection services,
                        Action<ParameterBindingStrategyResolver>? configure = null) where T : EntryPointAttribute
                    {
                        {{switchExpression}};
                        
                        throw new InvalidOperationException($"No entry point discovery strategy found for type '{typeof(T).FullName}'");   
                    }
                }
            }
            """);
    }
}