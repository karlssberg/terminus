using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Terminus.Generator;

internal static class EntryPointRegistrationSourceBuilder
{
    internal static CompilationUnitSyntax Generate(
        INamedTypeSymbol entryPointAttributeType,
        ImmutableArray<EntryPointMethodInfo> entryPointMethodInfos,
        ImmutableArray<MediatorInterfaceInfo> mediators)
    {
        var mediatorTypeDeclarations = mediators
            .Select(mediator => CreateMediatorTypeDeclarations(mediator, entryPointMethodInfos))
            .ToSyntaxList();
        
        var rawCompilationUnit =
          $$"""
            // <auto-generated/> Generated by Terminus EntryPointDiscoveryGenerator
            #nullable enable
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Reflection;
            using Terminus;
            using Terminus.Attributes;
            using Terminus.Strategies;

            {{mediatorTypeDeclarations}}

            namespace Terminus.Generated
            {
                public static partial class ServiceCollectionExtensions
                {
                    {{CreateAddEntryPointsExtension(entryPointAttributeType, mediators, entryPointMethodInfos)}}
                }
            }
            """;

        return ParseCompilationUnit(rawCompilationUnit).NormalizeWhitespace();
    }

    private static NamespaceDeclarationSyntax CreateMediatorTypeDeclarations(MediatorInterfaceInfo mediator, ImmutableArray<EntryPointMethodInfo> matchingEntryPoints)
    {
        var interfaceNamespace = mediator.InterfaceSymbol.ContainingNamespace.ToDisplayString();
        return NamespaceDeclaration(ParseName(interfaceNamespace))
            .WithMembers(
            [
                CreateMediatorInterfaceExtensionDeclaration(mediator, matchingEntryPoints),
                CreateMediatorClassImplementation(mediator, matchingEntryPoints)
            ])
            .NormalizeWhitespace();
    }

    private static InterfaceDeclarationSyntax CreateMediatorInterfaceExtensionDeclaration(
        MediatorInterfaceInfo mediatorInfo,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        return InterfaceDeclaration(mediatorInfo.InterfaceSymbol.Name)
            .WithModifiers(TokenList(Token(
                SyntaxKind.PublicKeyword), 
                Token(SyntaxKind.PartialKeyword)))
            .WithMembers(
                entryPoints
                    .Select(ep => ep.MethodSymbol.ToMethodDeclarationSyntax().WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))
                    .ToSyntaxList<MemberDeclarationSyntax>())
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax CreateMediatorClassImplementation(
        MediatorInterfaceInfo mediatorInfo,
        ImmutableArray<EntryPointMethodInfo> entryPoints)
    {
        var implementationClassName = mediatorInfo.GetImplementationClassName();
        return ClassDeclaration(implementationClassName)
            .WithModifiers([Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.SealedKeyword)])
            .AddBaseListTypes(SimpleBaseType(ParseTypeName(mediatorInfo.InterfaceSymbol.ToDisplayString())))
            .WithMembers(
            [
                ParseMemberDeclaration("private readonly IServiceProvider _serviceProvider;")!,
                ParseMemberDeclaration("private readonly ParameterBindingStrategyResolver _resolver;")!,
                ParseMemberDeclaration(
                   $$"""
                     public {{implementationClassName}}(IServiceProvider serviceProvider, ParameterBindingStrategyResolver resolver)
                     {
                         _serviceProvider = serviceProvider;
                         _resolver = resolver;
                     }
                     """)!,
                ..entryPoints.Select(CreateMediatorMethodImplementation),
            ]);
    }

    private static MemberDeclarationSyntax CreateMediatorMethodImplementation(EntryPointMethodInfo entryPoint)
    {
        // Build return type
        TypeSyntax returnTypeSyntax = entryPoint.MethodSymbol.ReturnsVoid
            ? PredefinedType(Token(SyntaxKind.VoidKeyword))
            : ParseTypeName(entryPoint.MethodSymbol.ReturnType.ToDisplayString());

        // Build parameter list
        var parameterList = ParameterList(SeparatedList(
            entryPoint.MethodSymbol.Parameters.Select(p =>
                Parameter(Identifier(p.Name))
                    .WithType(ParseTypeName(p.Type.ToDisplayString()))
            )));

        // Build instance/service resolution expression
        ExpressionSyntax instanceExpression;
        instanceExpression = ParseExpression(entryPoint.MethodSymbol.IsStatic
            ? entryPoint.MethodSymbol.ContainingType.ToDisplayString() : 
            $"scope.ServiceProvider.GetRequiredService<{entryPoint.MethodSymbol.ContainingType.ToDisplayString()}>()");

        // Build method invocation
        var methodAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            instanceExpression,
            IdentifierName(entryPoint.MethodSymbol.Name));

        var argumentList = ArgumentList(SeparatedList(
            entryPoint.MethodSymbol.Parameters.Select(p => Argument(IdentifierName(p.Name)))
        ));

        var invocationExpression = InvocationExpression(methodAccess, argumentList);

        // Return or expression statement depending on void
        StatementSyntax innerStatement = entryPoint.MethodSymbol.ReturnsVoid
            ? ExpressionStatement(invocationExpression)
            : ReturnStatement(invocationExpression);

        var usingStatement = entryPoint.MethodSymbol.IsAsync
            ? CreateUsingStatementWithCreateAsyncScope(innerStatement)
            : CreateUsingStatementWithCreateScope(innerStatement);

        var body = Block(usingStatement);

        var method = MethodDeclaration(returnTypeSyntax, Identifier(entryPoint.MethodSymbol.Name))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(parameterList)
            .WithBody(body);

        return method.NormalizeWhitespace();
    }

    private static UsingStatementSyntax CreateUsingStatementWithCreateScope(StatementSyntax innerStatement)
    {
        // using (var scope = _serviceProvider.CreateScope()) { ... }
        var createScopeAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            IdentifierName("_serviceProvider"),
            IdentifierName("CreateScope"));

        return UsingStatement(Block(innerStatement))
            .WithDeclaration(
                VariableDeclaration(IdentifierName("var"))
                    .WithVariables(SingletonSeparatedList(
                        VariableDeclarator(Identifier("scope"))
                            .WithInitializer(EqualsValueClause(
                                InvocationExpression(createScopeAccess))))));
    }

    private static UsingStatementSyntax CreateUsingStatementWithCreateAsyncScope(StatementSyntax innerStatement)
    {
        // await using (var scope = _serviceProvider.CreateAsyncScope()) { ... }
        var createScopeAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            IdentifierName("_serviceProvider"),
            IdentifierName("CreateAsyncScope"));

        return UsingStatement(Block(innerStatement))
            .WithAwaitKeyword(Token(SyntaxKind.AwaitKeyword))
            .WithDeclaration(
                VariableDeclaration(IdentifierName("var"))
                    .WithVariables(SingletonSeparatedList(
                        VariableDeclarator(Identifier("scope"))
                            .WithInitializer(EqualsValueClause(
                                InvocationExpression(createScopeAccess))))));
    }

    private static string CreateAddEntryPointsExtension(
        INamedTypeSymbol entryPointAttributeType,
        ImmutableArray<MediatorInterfaceInfo> mediators,
        ImmutableArray<EntryPointMethodInfo> entryPointMethodInfos)
    {
        var attributeTypeName = entryPointAttributeType.ToDisplayString();
     
        var entryPointRegistrations = entryPointMethodInfos
            .Select(ep =>
            {
                var methodName = ep.MethodSymbol.Name;
                var containingType = ep.MethodSymbol.ContainingType.ToDisplayString();
                var paramTypes = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                    $"typeof({p.Type.ToDisplayString()})"));
                var paramArray = ep.MethodSymbol.Parameters.Length == 0
                    ? "new System.Type[] { }"
                    : $"new System.Type[] {{ {paramTypes} }}";
                
                var parameterInvocations = string.Join(", ", ep.MethodSymbol.Parameters.Select(p =>
                    p.Type.ToDisplayString() == "System.Threading.CancellationToken"
                        ? "ct"
                        : $"resolver.ResolveParameter<{p.Type.ToDisplayString()}>(\"{p.Name}\", context)"));

                var invokeExpressionSnippet = ep.MethodSymbol.IsStatic
                    ? $"{containingType}.{methodName}({parameterInvocations})"
                    : $"context.ServiceProvider.GetRequiredService<{containingType}>().{methodName}({parameterInvocations})";
                    
                var invokeExpression = ParseExpression(invokeExpressionSnippet);

                var registrationExpressionStatement =
                    $"services.AddSingleton<EntryPointDescriptor<{attributeTypeName}>>(new EntryPointDescriptor<{attributeTypeName}>(typeof({containingType}).GetMethod(\"{methodName}\", {paramArray})!, (context, ct) => {invokeExpression}));";
                return ParseStatement(registrationExpressionStatement);
            })
            .ToSyntaxList();

        var entryPointContainingTypeCollection = entryPointMethodInfos
            .Where(ep => !ep.MethodSymbol.ContainingType.IsStatic)
            .Select(ep => ParseStatement(
                $"services.AddTransient<{ep.MethodSymbol.ContainingType.ToDisplayString()}>();"))
            .ToSyntaxList();
        
        var mediatorServiceRegistrations = mediators
            .Select(mediator => ParseExpression(
                $"services.AddSingleton<{mediator.InterfaceSymbol.ToDisplayString()}, {mediator.GetImplementationClassFullName()}>()"))
            .Select(ExpressionStatement)
            .ToSyntaxList();

        return
          $$"""
            private static IServiceCollection AddEntryPointsFor_{{attributeTypeName.EscapeIdentifierName()}}(
                this IServiceCollection services,
                Action<ParameterBindingStrategyResolver>? configure = null)
            {
                var resolver = new ParameterBindingStrategyResolver();
                configure?.Invoke(resolver);
                services.AddSingleton(resolver);
                services.AddTransient<IDispatcher<{{attributeTypeName}}>, ScopedDispatcher<{{attributeTypeName}}>>();
                services.AddTransient<IAsyncDispatcher<{{attributeTypeName}}>, ScopedDispatcher<{{attributeTypeName}}>>();
                services.AddTransient<IEntryPointRouter<{{attributeTypeName}}>, DefaultEntryPointRouter<{{attributeTypeName}}>>();
 
                {{entryPointRegistrations}}
                
                {{entryPointContainingTypeCollection}}
 
                {{mediatorServiceRegistrations}}
 
                return services;
            }
            """;
    }

    public static CompilationUnitSyntax Generate(ImmutableArray<INamedTypeSymbol> entryPointAttributeTypes)
    {
        var switchExpression =
            SwitchStatement(ParseExpression("typeof(T).FullName"))
                .AddSections(entryPointAttributeTypes
                    .Select(attributeType =>
                        SwitchSection()
                            .AddLabels(
                                CaseSwitchLabel(LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    Literal(attributeType.ToDisplayString()))))
                            .AddStatements(
                                ReturnStatement(
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("services"),
                                            IdentifierName(
                                                $"AddEntryPointsFor_{attributeType.ToDisplayString().EscapeIdentifierName()}")))
                                        .WithArgumentList(ParseArgumentList("(configure)")))))
                    .ToArray())
                .NormalizeWhitespace();

        var registerAllEntryPoints = entryPointAttributeTypes
            .Select(attributeType => ParseStatement(
                $"services.AddEntryPointsFor_{attributeType.ToDisplayString().EscapeIdentifierName()}();"))
            .ToSyntaxList();


        var compilationUnit = $$"""
                     #nullable enable
                     using Microsoft.Extensions.DependencyInjection;
                     using System;
                     using Terminus.Attributes;

                     namespace Terminus.Generated
                     {
                         public static partial class ServiceCollectionExtensions
                         {
                             public static IServiceCollection AddEntryPoints<T>(
                                 this IServiceCollection services,
                                 Action<ParameterBindingStrategyResolver>? configure = null) where T : EntryPointAttribute
                             {
                                 {{switchExpression}};
                                 
                                 throw new InvalidOperationException($"No entry point discovery strategy found for type '{typeof(T).FullName}'");   
                             }
                             
                             public static IServiceCollection AddEntryPoints(
                                 this IServiceCollection services,
                                 Action<ParameterBindingStrategyResolver>? configure = null)
                             {
                                 {{registerAllEntryPoints}}
                                 
                                 return services;
                             }
                         }
                     }
                     """;
        
        return ParseCompilationUnit(compilationUnit).NormalizeWhitespace();
    }
}