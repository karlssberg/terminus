using System.Text;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Terminus.Generator.Tests.Unit.Generator.Infrastructure;

namespace Terminus.Generator.Tests.Unit.Generator;

public class CrossAssemblyDiscoveryTests
{
    [Fact]
    public async Task Given_method_in_referenced_assembly_with_IncludeReferencedAssemblies_true_Should_include_method()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.ReferencedAssemblies)]
                public partial interface IFacade;
            }
            """;

        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleExternal(string)"/>
                    /// </summary>
                    void HandleExternal(string message);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleExternal(string message)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleExternal(message);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_method_in_referenced_assembly_with_IncludeReferencedAssemblies_false_Should_not_include_method()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project (without IncludeReferencedAssemblies)
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute))]
                public partial interface IFacade;
            }
            """;

        // Act & Assert: No generated sources expected (no methods matched)
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestBehaviors |= TestBehaviors.SkipGeneratedSourcesCheck;

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_class_level_attribute_in_referenced_assembly_Should_include_all_public_methods()
    {
        // Arrange: Source code for the referenced assembly with class-level attribute
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                [Handler]
                public class ExternalHandlers
                {
                    public void HandleOne(string message) { }
                    public void HandleTwo(int id) { }
                    private void InternalMethod() { }
                }
            }
            """;

        // Arrange: Source code for the main project
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.ReferencedAssemblies)]
                public partial interface IFacade;
            }
            """;

        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleOne(string)"/>
                    /// </summary>
                    void HandleOne(string message);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleTwo(int)"/>
                    /// </summary>
                    void HandleTwo(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleOne(string message)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleOne(message);
                    }

                    void global::Demo.IFacade.HandleTwo(int id)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleTwo(id);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_mixed_local_and_referenced_methods_Should_include_both()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project with local handler
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.ReferencedAssemblies)]
                public partial interface IFacade;

                public class LocalHandlers
                {
                    [Handler]
                    public void HandleLocal(int id) { }
                }
            }
            """;

        // Note: Local methods come before referenced assembly methods in the output
        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to:<br/>
                /// <see cref="Demo.LocalHandlers"/><br/>
                /// <see cref="ExternalLib.ExternalHandlers"/><br/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.LocalHandlers.HandleLocal(int)"/>
                    /// </summary>
                    void HandleLocal(int id);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleExternal(string)"/>
                    /// </summary>
                    void HandleExternal(string message);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to:<br/>
                /// <see cref="Demo.LocalHandlers"/><br/>
                /// <see cref="ExternalLib.ExternalHandlers"/><br/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleLocal(int id)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LocalHandlers>(_serviceProvider).HandleLocal(id);
                    }

                    void global::Demo.IFacade.HandleExternal(string message)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleExternal(message);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_static_method_in_referenced_assembly_Should_call_directly()
    {
        // Arrange: Source code for the referenced assembly with static method
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public static class StaticHandlers
                {
                    [Handler]
                    public static void HandleStatic(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.ReferencedAssemblies)]
                public partial interface IFacade;
            }
            """;

        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="ExternalLib.StaticHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.StaticHandlers.HandleStatic(string)"/>
                    /// </summary>
                    void HandleStatic(string message);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="ExternalLib.StaticHandlers"/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleStatic(string message)
                    {
                        global::ExternalLib.StaticHandlers.HandleStatic(message);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }



    [Fact]
    public async Task Given_MethodDiscovery_TransitiveAssemblies_Should_include_referenced_assembly_methods()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project using new MethodDiscovery enum
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.TransitiveAssemblies)]
                public partial interface IFacade;
            }
            """;

        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleExternal(string)"/>
                    /// </summary>
                    void HandleExternal(string message);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleExternal(string message)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleExternal(message);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_MethodDiscovery_ReferencedAssemblies_Should_include_direct_references_only()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project using ReferencedAssemblies mode
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.ReferencedAssemblies)]
                public partial interface IFacade;
            }
            """;

        const string expectedOutput =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="ExternalLib.ExternalHandlers.HandleExternal(string)"/>
                    /// </summary>
                    void HandleExternal(string message);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="ExternalLib.ExternalHandlers"/>
                /// </summary>
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IFacade_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    void global::Demo.IFacade.HandleExternal(string message)
                    {
                        global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::ExternalLib.ExternalHandlers>(_serviceProvider).HandleExternal(message);
                    }
                }
            }
            """;

        // Act & Assert
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestState.GeneratedSources.Add(
            (typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs",
             SourceText.From(NormalizeLineEndings(expectedOutput), Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_MethodDiscovery_None_Should_not_include_referenced_assembly_methods()
    {
        // Arrange: Source code for the referenced assembly
        const string referencedAssemblySource =
            """
            using System;
            using Terminus;

            namespace ExternalLib
            {
                public class HandlerAttribute : Attribute { }

                public class ExternalHandlers
                {
                    [Handler]
                    public void HandleExternal(string message) { }
                }
            }
            """;

        // Arrange: Source code for the main project with MethodDiscovery = None
        const string mainSource =
            """
            using System;
            using Terminus;
            using ExternalLib;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute), MethodDiscovery = MethodDiscoveryMode.None)]
                public partial interface IFacade;
            }
            """;

        // Act & Assert: No generated sources expected (no methods matched)
        var test = new TerminusSourceGeneratorTest<FacadeGenerator>();
        await test.AddReferencedAssemblyFromSourceAsync(referencedAssemblySource, "ExternalLib");
        test.TestState.Sources.Add(mainSource);
        test.TestBehaviors |= TestBehaviors.SkipGeneratedSourcesCheck;

        await test.RunAsync();
    }
    private static string NormalizeLineEndings(string text)
    {
        return text
            .Replace("\r\n", "\n")
            .Replace("\r", "\n")
            .Replace("\n", Environment.NewLine);
    }
}
