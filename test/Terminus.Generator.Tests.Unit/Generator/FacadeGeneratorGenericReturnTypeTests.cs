using Microsoft.CodeAnalysis.Text;
using System.Text;
using Terminus.Generator.Tests.Unit.Generator.Infrastructure;

namespace Terminus.Generator.Tests.Unit.Generator;

public class FacadeGeneratorGenericReturnTypeTests : SourceGeneratorTestBase<FacadeGenerator>
{
    private const string SourceFilename = "Source.cs";

    [Fact]
    public async Task Given_generic_methods_with_various_return_types_Should_generate_correct_facade_methods()
    {
        const string source =
            """
            using System;
            using System.Collections.Generic;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                [FacadeOf(typeof(FacadeMethodAttribute))]
                public partial interface IFacade;
                
                public class FacadeMethodAttribute : Attribute;

                public class TestService
                {
                    [FacadeMethod]
                    public Task DoAsync<T>(T value) => Task.CompletedTask;

                    [FacadeMethod]
                    public ValueTask ProcessValueAsync<T>(T value) => default;

                    [FacadeMethod]
                    public ValueTask<T> GetValueAsync<T>(T value) => new ValueTask<T>(value);

                    [FacadeMethod]
                    public async IAsyncEnumerable<T> StreamAsync<T>(T value)
                    {
                        yield return value;
                        await Task.Yield();
                    }
                }
            }
            """;

        const string expectedInterface =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.TestService"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.TestService.DoAsync(T)"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task DoAsync<T>(T value);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.TestService.ProcessValueAsync(T)"/>
                    /// </summary>
                    global::System.Threading.Tasks.ValueTask ProcessValueAsync<T>(T value);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.TestService.GetValueAsync(T)"/>
                    /// </summary>
                    global::System.Threading.Tasks.ValueTask<T> GetValueAsync<T>(T value);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.TestService.StreamAsync(T)"/>
                    /// </summary>
                    global::System.Collections.Generic.IAsyncEnumerable<T> StreamAsync<T>(T value);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IFacade))]
                public sealed class IFacade_Generated : global::Demo.IFacade
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    public IFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    async global::System.Threading.Tasks.Task global::Demo.IFacade.DoAsync<T>(T value)
                    {
                        await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.TestService>(_serviceProvider).DoAsync<T>(value).ConfigureAwait(false);
                    }

                    async global::System.Threading.Tasks.ValueTask global::Demo.IFacade.ProcessValueAsync<T>(T value)
                    {
                        await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.TestService>(_serviceProvider).ProcessValueAsync<T>(value).ConfigureAwait(false);
                    }

                    async global::System.Threading.Tasks.ValueTask<T> global::Demo.IFacade.GetValueAsync<T>(T value)
                    {
                        return await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.TestService>(_serviceProvider).GetValueAsync<T>(value).ConfigureAwait(false);
                    }

                    global::System.Collections.Generic.IAsyncEnumerable<T> global::Demo.IFacade.StreamAsync<T>(T value)
                    {
                        return global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.TestService>(_serviceProvider).StreamAsync<T>(value);
                    }
                }
            }
            """;

        var test = new TerminusSourceGeneratorTest<FacadeGenerator>
        {
            TestState = { Sources = { source } }
        };

        test.TestState.GeneratedSources.Add((typeof(FacadeGenerator), "Demo_IFacade_Generated.g.cs", SourceText.From(expectedInterface, Encoding.UTF8)));

        await test.RunAsync();
    }

    [Fact]
    public async Task Given_scoped_facade_with_generic_stream_Should_generate_correct_proxy_iterator()
    {
        const string source =
            """
            using System;
            using System.Collections.Generic;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                [FacadeOf(typeof(FacadeMethodAttribute), Scoped = true)]
                public partial interface IScopedFacade;
                
                public class FacadeMethodAttribute : Attribute;

                public class TestService
                {
                    [FacadeMethod]
                    public async IAsyncEnumerable<T> StreamAsync<T>(T value)
                    {
                        yield return value;
                        await Task.Yield();
                    }
                }
            }
            """;

        const string expectedInterface =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.TestService"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IScopedFacade
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.TestService.StreamAsync(T)"/>
                    /// </summary>
                    global::System.Collections.Generic.IAsyncEnumerable<T> StreamAsync<T>(T value);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IScopedFacade))]
                public sealed class IScopedFacade_Generated : global::Demo.IScopedFacade, global::System.IDisposable, global::System.IAsyncDisposable
                {
                    private bool _syncDisposed;
                    private bool _asyncDisposed;
                    private readonly global::System.Lazy<global::Microsoft.Extensions.DependencyInjection.IServiceScope> _syncScope;
                    private readonly global::System.Lazy<global::Microsoft.Extensions.DependencyInjection.AsyncServiceScope> _asyncScope;
                    public IScopedFacade_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _syncScope = new global::System.Lazy<global::Microsoft.Extensions.DependencyInjection.IServiceScope>(() => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Microsoft.Extensions.DependencyInjection.IServiceScopeFactory>(serviceProvider).CreateScope());
                        _asyncScope = new global::System.Lazy<global::Microsoft.Extensions.DependencyInjection.AsyncServiceScope>(() => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateAsyncScope(serviceProvider));
                    }

                    async global::System.Collections.Generic.IAsyncEnumerable<T> global::Demo.IScopedFacade.StreamAsync<T>(T value)
                    {
                        await foreach (var item in global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.TestService>(_asyncScope.Value.ServiceProvider).StreamAsync<T>(value))
                        {
                            yield return item;
                        }
                    }

                    public void Dispose()
                    {
                        if (_syncDisposed || !_syncScope.IsValueCreated)
                            return;
                        _syncScope.Value.Dispose();
                        _syncDisposed = true;
                        global::System.GC.SuppressFinalize(this);
                    }

                    public async global::System.Threading.Tasks.ValueTask DisposeAsync()
                    {
                        if (_asyncDisposed || !_asyncScope.IsValueCreated)
                            return;
                        await _asyncScope.Value.DisposeAsync().ConfigureAwait(false);
                        _asyncDisposed = true;
                        global::System.GC.SuppressFinalize(this);
                    }
                }
            }
            """;

        var test = new TerminusSourceGeneratorTest<FacadeGenerator>
        {
            TestState = { Sources = { source } }
        };

        test.TestState.GeneratedSources.Add((typeof(FacadeGenerator), "Demo_IScopedFacade_Generated.g.cs", SourceText.From(expectedInterface, Encoding.UTF8)));

        await test.RunAsync();
    }
}
