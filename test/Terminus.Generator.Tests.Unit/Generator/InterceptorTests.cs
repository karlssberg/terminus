namespace Terminus.Generator.Tests.Unit.Generator;

public class InterceptorTests : SourceGeneratorTestBase<FacadeGenerator>
{
    [Fact]
    public async Task Given_single_interceptor_with_void_method_Should_generate_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public void DeleteUser(int id)
                    {
                        Console.WriteLine($"Deleted user {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.DeleteUser(int)"/>
                    /// </summary>
                    void DeleteUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    void global::Demo.IHandlers.DeleteUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeVoidHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeVoidHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).DeleteUser(id))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("DeleteUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Void, handlers, isAggregated: false);
                        ExecuteWithVoidInterceptors(context, handlers => ((global::Terminus.FacadeVoidHandlerDescriptor)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    private void ExecuteWithVoidInterceptors(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeVoidInvocationDelegate target)
                    {
                        var index = 0;
                        global::Terminus.FacadeVoidInvocationDelegate BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncVoidFacadeInterceptor syncVoid)
                                return handlers => syncVoid.Intercept(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        BuildPipeline()(null);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_single_interceptor_with_result_method_Should_generate_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeSyncHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeSyncHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, handlers => ((global::Terminus.FacadeSyncHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    private TResult ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return handlers => sync.Intercept(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return BuildPipeline()(null);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

#if !NET472
    [Fact]
    public async Task Given_single_interceptor_with_async_task_method_Should_generate_async_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public Task ProcessAsync()
                    {
                        return Task.CompletedTask;
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.ProcessAsync"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task ProcessAsync();
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    async global::System.Threading.Tasks.Task global::Demo.IHandlers.ProcessAsync()
                    {
                        var handlers = new global::Terminus.FacadeAsyncVoidHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeAsyncVoidHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, async () => await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).ProcessAsync().ConfigureAwait(false))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("ProcessAsync")!, new object? [] { }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Task, handlers, isAggregated: false);
                        await ExecuteWithAsyncVoidInterceptors(context, async handlers => await ((global::Terminus.FacadeAsyncVoidHandlerDescriptor)(handlers ?? context.Handlers)[0]).InvokeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                    }

                    private async global::System.Threading.Tasks.Task ExecuteWithAsyncVoidInterceptors(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncVoidInvocationDelegate target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncVoidInvocationDelegate BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncVoidFacadeInterceptor asyncVoid)
                                return handlers => asyncVoid.InterceptAsync(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        await BuildPipeline()(null).ConfigureAwait(false);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

#if !NET472
    [Fact]
    public async Task Given_single_interceptor_with_async_task_result_method_Should_generate_async_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public Task<string> GetUserAsync(int id)
                    {
                        return Task.FromResult($"User {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUserAsync(int)"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task<string> GetUserAsync(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    async global::System.Threading.Tasks.Task<string> global::Demo.IHandlers.GetUserAsync(int id)
                    {
                        var handlers = new global::Terminus.FacadeAsyncHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeAsyncHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, async () => await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUserAsync(id).ConfigureAwait(false))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUserAsync")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.TaskWithResult, handlers, isAggregated: false);
                        return await ExecuteWithInterceptorsAsync<string>(context, async handlers => await ((global::Terminus.FacadeAsyncHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).InvokeAsync()).ConfigureAwait(false);
                    }

                    private async global::System.Threading.Tasks.ValueTask<TResult> ExecuteWithInterceptorsAsync<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncFacadeInterceptor async)
                                return handlers => async.InterceptAsync(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return await BuildPipeline()(null).ConfigureAwait(false);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

    [Fact]
    public async Task Given_multiple_interceptors_Should_generate_interceptor_array_in_order()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;
                public class CachingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor), typeof(CachingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider),
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.CachingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeSyncHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeSyncHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, handlers => ((global::Terminus.FacadeSyncHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    private TResult ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return handlers => sync.Intercept(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return BuildPipeline()(null);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_no_interceptors_Should_generate_original_code_without_interceptor_overhead()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute))]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        return global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_interceptors_with_static_method_Should_generate_static_invocation_in_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public static class StaticHandlers
                {
                    [Handler]
                    public static void Process(string data)
                    {
                        Console.WriteLine(data);
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.StaticHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.StaticHandlers.Process(string)"/>
                    /// </summary>
                    void Process(string data);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.StaticHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    void global::Demo.IHandlers.Process(string data)
                    {
                        var handlers = new global::Terminus.FacadeVoidHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeVoidHandlerDescriptor(typeof(global::Demo.StaticHandlers), new global::Demo.HandlerAttribute(), isStatic: true, () => global::Demo.StaticHandlers.Process(data))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("Process")!, new object? [] { data }, typeof(global::Demo.StaticHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Void, handlers, isAggregated: false);
                        ExecuteWithVoidInterceptors(context, handlers => ((global::Terminus.FacadeVoidHandlerDescriptor)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    private void ExecuteWithVoidInterceptors(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeVoidInvocationDelegate target)
                    {
                        var index = 0;
                        global::Terminus.FacadeVoidInvocationDelegate BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncVoidFacadeInterceptor syncVoid)
                                return handlers => syncVoid.Intercept(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        BuildPipeline()(null);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
    [Fact]
    public async Task Given_single_interceptor_with_async_enumerable_method_Should_generate_stream_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Collections.Generic;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public async IAsyncEnumerable<string> StreamUsersAsync()
                    {
                        yield return "User1";
                        yield return "User2";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.StreamUsersAsync"/>
                    /// </summary>
                    global::System.Collections.Generic.IAsyncEnumerable<string> StreamUsersAsync();
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    global::System.Collections.Generic.IAsyncEnumerable<string> global::Demo.IHandlers.StreamUsersAsync()
                    {
                        var handlers = new global::Terminus.FacadeStreamHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeStreamHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).StreamUsersAsync())
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("StreamUsersAsync")!, new object? [] { }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.AsyncEnumerable, handlers, isAggregated: false);
                        return ExecuteWithInterceptorsStream<string>(context, handlers => ((global::Terminus.FacadeStreamHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    private global::System.Collections.Generic.IAsyncEnumerable<TItem> ExecuteWithInterceptorsStream<TItem>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeStreamInvocationDelegate<TItem> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeStreamInvocationDelegate<TItem> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IStreamFacadeInterceptor stream)
                                return handlers => stream.InterceptStream(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return BuildPipeline()(null);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

#if !NET472
    [Fact]
    public async Task Given_interceptors_with_mixed_sync_and_async_methods_Should_generate_both_pipeline_methods()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }

                    [Handler]
                    public Task<string> GetUserAsync(int id)
                    {
                        return Task.FromResult($"User {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUserAsync(int)"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task<string> GetUserAsync(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeSyncHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeSyncHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, handlers => ((global::Terminus.FacadeSyncHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).Invoke());
                    }

                    async global::System.Threading.Tasks.Task<string> global::Demo.IHandlers.GetUserAsync(int id)
                    {
                        var handlers = new global::Terminus.FacadeAsyncHandlerDescriptor<string>[]
                        {
                            new global::Terminus.FacadeAsyncHandlerDescriptor<string>(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false, async () => await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUserAsync(id).ConfigureAwait(false))
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUserAsync")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.TaskWithResult, handlers, isAggregated: false);
                        return await ExecuteWithInterceptorsAsync<string>(context, async handlers => await ((global::Terminus.FacadeAsyncHandlerDescriptor<string>)(handlers ?? context.Handlers)[0]).InvokeAsync()).ConfigureAwait(false);
                    }

                    private TResult ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return handlers => sync.Intercept(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return BuildPipeline()(null);
                    }

                    private async global::System.Threading.Tasks.ValueTask<TResult> ExecuteWithInterceptorsAsync<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncFacadeInterceptor async)
                                return handlers => async.InterceptAsync(context, nextHandlers => next(nextHandlers ?? handlers));
                            return next;
                        }

                        return await BuildPipeline()(null).ConfigureAwait(false);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif
}
