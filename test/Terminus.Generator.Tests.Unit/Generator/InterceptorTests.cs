namespace Terminus.Generator.Tests.Unit.Generator;

public class InterceptorTests : SourceGeneratorTestBase<FacadeGenerator>
{
    [Fact]
    public async Task Given_single_interceptor_with_void_method_Should_generate_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public void DeleteUser(int id)
                    {
                        Console.WriteLine($"Deleted user {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.DeleteUser(int)"/>
                    /// </summary>
                    void DeleteUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    void global::Demo.IHandlers.DeleteUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("DeleteUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Void, handlers, isAggregated: false);
                        ExecuteWithInterceptors<object>(context, () =>
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).DeleteUser(id);
                            return default;
                        });
                    }

                    private TResult? ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return () => sync.Intercept(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_single_interceptor_with_result_method_Should_generate_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))!;
                    }

                    private TResult? ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return () => sync.Intercept(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

#if !NET472
    [Fact]
    public async Task Given_single_interceptor_with_async_task_method_Should_generate_async_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public Task ProcessAsync()
                    {
                        return Task.CompletedTask;
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.ProcessAsync"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task ProcessAsync();
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    async global::System.Threading.Tasks.Task global::Demo.IHandlers.ProcessAsync()
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("ProcessAsync")!, new object? [] { }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Task, handlers, isAggregated: false);
                        await ExecuteWithInterceptorsAsync<object>(context, async () =>
                        {
                            await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).ProcessAsync().ConfigureAwait(false);
                            return default;
                        }).ConfigureAwait(false);
                    }

                    private async global::System.Threading.Tasks.ValueTask<TResult?> ExecuteWithInterceptorsAsync<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncFacadeInterceptor async)
                                return () => async.InterceptAsync(context, next);
                            return next;
                        }

                        return await BuildPipeline()().ConfigureAwait(false);
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

#if !NET472
    [Fact]
    public async Task Given_single_interceptor_with_async_task_result_method_Should_generate_async_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public Task<string> GetUserAsync(int id)
                    {
                        return Task.FromResult($"User {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUserAsync(int)"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task<string> GetUserAsync(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    async global::System.Threading.Tasks.Task<string> global::Demo.IHandlers.GetUserAsync(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUserAsync")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.TaskWithResult, handlers, isAggregated: false);
                        return (await ExecuteWithInterceptorsAsync<string>(context, async () => await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUserAsync(id).ConfigureAwait(false)).ConfigureAwait(false))!;
                    }

                    private async global::System.Threading.Tasks.ValueTask<TResult?> ExecuteWithInterceptorsAsync<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncFacadeInterceptor async)
                                return () => async.InterceptAsync(context, next);
                            return next;
                        }

                        return await BuildPipeline()().ConfigureAwait(false);
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

    [Fact]
    public async Task Given_multiple_interceptors_Should_generate_interceptor_array_in_order()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;
                public class CachingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor), typeof(CachingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider),
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.CachingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))!;
                    }

                    private TResult? ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return () => sync.Intercept(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_no_interceptors_Should_generate_original_code_without_interceptor_overhead()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                [FacadeOf(typeof(HandlerAttribute))]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        return global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id);
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

    [Fact]
    public async Task Given_interceptors_with_static_method_Should_generate_static_invocation_in_interceptor_chain()
    {
        const string source =
            """
            using System;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public static class StaticHandlers
                {
                    [Handler]
                    public static void Process(string data)
                    {
                        Console.WriteLine(data);
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.StaticHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.StaticHandlers.Process(string)"/>
                    /// </summary>
                    void Process(string data);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.StaticHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    void global::Demo.IHandlers.Process(string data)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.StaticHandlers), new global::Demo.HandlerAttribute(), isStatic: true)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("Process")!, new object? [] { data }, typeof(global::Demo.StaticHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Void, handlers, isAggregated: false);
                        ExecuteWithInterceptors<object>(context, () =>
                        {
                            global::Demo.StaticHandlers.Process(data);
                            return default;
                        });
                    }

                    private TResult? ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return () => sync.Intercept(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
    [Fact]
    public async Task Given_single_interceptor_with_async_enumerable_method_Should_generate_stream_interceptor_chain()
    {
        const string source =
            """
            using System;
            using System.Collections.Generic;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public async IAsyncEnumerable<string> StreamUsersAsync()
                    {
                        yield return "User1";
                        yield return "User2";
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.StreamUsersAsync"/>
                    /// </summary>
                    global::System.Collections.Generic.IAsyncEnumerable<string> StreamUsersAsync();
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    global::System.Collections.Generic.IAsyncEnumerable<string> global::Demo.IHandlers.StreamUsersAsync()
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("StreamUsersAsync")!, new object? [] { }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.AsyncEnumerable, handlers, isAggregated: false);
                        return ExecuteWithInterceptorsStream<string>(context, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).StreamUsersAsync());
                    }

                    private global::System.Collections.Generic.IAsyncEnumerable<TItem> ExecuteWithInterceptorsStream<TItem>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeStreamInvocationDelegate<TItem> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeStreamInvocationDelegate<TItem> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IStreamFacadeInterceptor stream)
                                return () => stream.InterceptStream(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif

#if !NET472
    [Fact]
    public async Task Given_interceptors_with_mixed_sync_and_async_methods_Should_generate_both_pipeline_methods()
    {
        const string source =
            """
            using System;
            using System.Threading.Tasks;
            using Terminus;

            namespace Demo
            {
                public class LoggingInterceptor : FacadeInterceptor;

                [FacadeOf(typeof(HandlerAttribute), Interceptors = new[] { typeof(LoggingInterceptor) })]
                public partial interface IHandlers;

                public class HandlerAttribute : Attribute;

                public class UserHandlers
                {
                    [Handler]
                    public string GetUser(int id)
                    {
                        return $"User {id}";
                    }

                    [Handler]
                    public Task<string> GetUserAsync(int id)
                    {
                        return Task.FromResult($"User {id}");
                    }
                }
            }
            """;

        const string expectedMainSource =
            """
            // <auto-generated/> Generated by Terminus FacadeGenerator
            #nullable enable
            namespace Demo
            {
                /// <summary>
                /// Facade interface delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                public partial interface IHandlers
                {
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUser(int)"/>
                    /// </summary>
                    string GetUser(int id);
                    /// <summary>
                    /// Delegates to:<br/>
                    /// <see cref="Demo.UserHandlers.GetUserAsync(int)"/>
                    /// </summary>
                    global::System.Threading.Tasks.Task<string> GetUserAsync(int id);
                }

                [global::System.CodeDom.Compiler.GeneratedCode("Terminus.Generator", "1.0.0")]
                [global::Terminus.FacadeImplementation(typeof(global::Demo.IHandlers))]
                /// <summary>
                /// Facade implementation class delegating to: <see cref="Demo.UserHandlers"/>
                /// </summary>
                public sealed class IHandlers_Generated : global::Demo.IHandlers
                {
                    private readonly global::System.IServiceProvider _serviceProvider;
                    private readonly object[] _interceptors;
                    /// <summary>
                    /// Initializes a new instance of the IHandlers_Generated class.
                    /// </summary>
                    /// <param name = "serviceProvider">The service provider used for resolving dependencies.</param>
                    public IHandlers_Generated(global::System.IServiceProvider serviceProvider)
                    {
                        _serviceProvider = serviceProvider;
                        _interceptors = new object[]
                        {
                            global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.LoggingInterceptor>(serviceProvider)
                        };
                    }

                    string global::Demo.IHandlers.GetUser(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUser")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.Result, handlers, isAggregated: false);
                        return ExecuteWithInterceptors<string>(context, () => global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUser(id))!;
                    }

                    async global::System.Threading.Tasks.Task<string> global::Demo.IHandlers.GetUserAsync(int id)
                    {
                        var handlers = new global::Terminus.FacadeHandlerDescriptor[]
                        {
                            new global::Terminus.FacadeHandlerDescriptor(typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), isStatic: false)
                        };
                        var context = new global::Terminus.FacadeInvocationContext(_serviceProvider, typeof(global::Demo.IHandlers).GetMethod("GetUserAsync")!, new object? [] { id }, typeof(global::Demo.UserHandlers), new global::Demo.HandlerAttribute(), new global::System.Collections.Generic.Dictionary<string, object?>(), global::Terminus.ReturnTypeKind.TaskWithResult, handlers, isAggregated: false);
                        return (await ExecuteWithInterceptorsAsync<string>(context, async () => await global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<global::Demo.UserHandlers>(_serviceProvider).GetUserAsync(id).ConfigureAwait(false)).ConfigureAwait(false))!;
                    }

                    private TResult? ExecuteWithInterceptors<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.ISyncFacadeInterceptor sync)
                                return () => sync.Intercept(context, next);
                            return next;
                        }

                        return BuildPipeline()();
                    }

                    private async global::System.Threading.Tasks.ValueTask<TResult?> ExecuteWithInterceptorsAsync<TResult>(global::Terminus.FacadeInvocationContext context, global::Terminus.FacadeAsyncInvocationDelegate<TResult> target)
                    {
                        var index = 0;
                        global::Terminus.FacadeAsyncInvocationDelegate<TResult> BuildPipeline()
                        {
                            if (index >= _interceptors.Length)
                                return target;
                            var currentIndex = index++;
                            var next = BuildPipeline();
                            if (_interceptors[currentIndex] is global::Terminus.IAsyncFacadeInterceptor async)
                                return () => async.InterceptAsync(context, next);
                            return next;
                        }

                        return await BuildPipeline()().ConfigureAwait(false);
                    }

                    private global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> FilterHandlers(global::Terminus.FacadeInvocationContext context)
                    {
                        global::System.Collections.Generic.IEnumerable<global::Terminus.FacadeHandlerDescriptor> handlers = context.Handlers;
                        foreach (var interceptor in _interceptors)
                        {
                            if (interceptor is global::Terminus.IAggregatableInterceptor aggregatable)
                            {
                                handlers = aggregatable.FilterHandlers(context, handlers is global::System.Collections.Generic.IReadOnlyList<global::Terminus.FacadeHandlerDescriptor> readOnlyList ? readOnlyList : global::System.Linq.Enumerable.ToList(handlers));
                            }
                        }

                        return handlers;
                    }
                }
            }
            """;

        await VerifyAsync(
            source,
            ("Demo_IHandlers_Generated.g.cs", expectedMainSource));
    }
#endif
}
